<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pete Smith</title>
    <link>https://petethedeveloper.com/tags/ios/index.xml</link>
    <description>Recent content on Pete Smith</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://petethedeveloper.com/tags/ios/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Swiftly changing a UISearchBar’s clear icon color</title>
      <link>https://petethedeveloper.com/post/uiSearchBarIconColors/</link>
      <pubDate>Wed, 05 Oct 2016 11:04:12 +0100</pubDate>
      
      <guid>https://petethedeveloper.com/post/uiSearchBarIconColors/</guid>
      <description>&lt;p&gt;&lt;em&gt;This is entirely based on &lt;a href=&#34;http://www.tanryan.com/2015/05/changing-icon-colors-on-uisearchbar-and-uitextfield/&#34;&gt;this&lt;/a&gt; Obj-C solution&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;We recently needed to customize the color of a UISearchBar’s clear button. In case you are unfamiliar, this is the clear button.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://petethedeveloper.com/images/posts/uiSearchBarIconColorsImage1.png&#34; alt=&#34;Searchbar before&#34; title=&#34;Searchbar before&#34; /&gt;&lt;/p&gt;

&lt;p&gt;It’s actually part of the UITextField which is embedded in a UISearchBar.&lt;/p&gt;

&lt;p&gt;So, how do we change the color of the clear icon? First, we checked the docs. Nothing. Really? Yes, really. Ok…quick search…and…perfect…we found the above post, which is a solution written in Obj-C.&lt;/p&gt;

&lt;p&gt;Converting this to Swift gives us the following concise solution;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;if let searchTextField = searchController.searchBar.valueForKey(&amp;quot;_searchField&amp;quot;) as? UITextField, let clearButton = searchTextField.valueForKey(&amp;quot;_clearButton&amp;quot;) as? UIButton {
   // Create a template copy of the original button image
   let templateImage =  clearButton.imageView?.image?.imageWithRenderingMode(.AlwaysTemplate)
   // Set the template image copy as the button image
   clearButton.setImage(templateImage, forState: .Normal)
   // Finally, set the image color
   clearButton.tintColor = .redColor()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And viola, we have our desired clear icon color.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://petethedeveloper.com/images/posts/uiSearchBarIconColorsImage2.png&#34; alt=&#34;Searchbar after&#34; title=&#34;Searchbar after&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Swift 3 &amp; CocoaPods</title>
      <link>https://petethedeveloper.com/post/swift3Cocoapods/</link>
      <pubDate>Sat, 24 Sep 2016 11:04:12 +0100</pubDate>
      
      <guid>https://petethedeveloper.com/post/swift3Cocoapods/</guid>
      <description>

&lt;p&gt;Have a CocoaPod which you updated to Swift 3? Great! Want to submit this updated Podspec to CocoaPods trunk? Awesome! Right, just run pod spec lint, and then…oh wait…it didn’t lint…&lt;/p&gt;

&lt;h2 id=&#34;the-problem&#34;&gt;The problem&lt;/h2&gt;

&lt;p&gt;Yep, you most likely got “ ‘Use Legacy Swift Language Version’ (SWIFT_VERSION) is required…”. Why? Well, Xcode 8 supports multiple Swift toolchains, and SWIFT_VERSION is an Xcode build setting indicating which Swift version to use when building your project. This build setting is required to be configured correctly for targets which use Swift. When CocoaPods is linting your pod it builds it, but this build will fail if the SWIFT_VERSION is not set.&lt;/p&gt;

&lt;h2 id=&#34;the-solution&#34;&gt;The solution&lt;/h2&gt;

&lt;p&gt;You need at least version 1.1.0.rc.2 of CocoaPods. Check your version&lt;/p&gt;

&lt;p&gt;You need at least version 1.1.0.rc.2 of CocoaPods. Check your version&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod --version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Uninstall your current version&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem uninstall cocoapods.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install the required version&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem install cocoapods -v 1.1.0.rc.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we need to specify our pod should be built with Swift 3, as the default version used is Swift 2.3. Create a .swift-version file in your root project directory&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;touch .swift-version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Edit this using your favorite editor&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod spec lint
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;watch it succeed, and have a celebratory cup of tea!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>iOS 10: Getting your Widget ready in 2 simple steps</title>
      <link>https://petethedeveloper.com/post/ios10Widget/</link>
      <pubDate>Tue, 16 Aug 2016 11:04:12 +0100</pubDate>
      
      <guid>https://petethedeveloper.com/post/ios10Widget/</guid>
      <description>

&lt;p&gt;iOS 10 turns widgets in to super-widgets. They now appear on the Home screen (3D touch on the app icon), and on the Search screen (swipe to the right on the Home screen or the Lock screen). But with &lt;a href=&#34;https://www.youtube.com/watch?v=b23wrRfy7SM&#34;&gt;great power, comes great responsibility&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If your app currently has a widget (i.e Today extension), you need to do a little bit of work to get it ready for it’s big day in September. This is how to get your widget iOS 10 ready in 2 simple steps.&lt;/p&gt;

&lt;h2 id=&#34;1-get-it-on-the-home-screen&#34;&gt;1. Get it on the Home screen&lt;/h2&gt;

&lt;p&gt;Getting your existing Today widget to display on the home screen via 3D touch is easy. Simply add an UIApplicationShortcutWidget entry to your app pList file specifying the bundle identifier of the widget you want to display, for example;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;key&amp;gt;UIApplicationShortcutWidget&amp;lt;/key
&amp;lt;string&amp;gt;com.yourName.yourApp.yourWidget&amp;lt;/string&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-a-widget-people-want-to-look-at&#34;&gt;2. A widget people want to look at&lt;/h2&gt;

&lt;p&gt;As Apple state, our “goal should be to design a widget that people want to add to the Search screen”. With iOS 10, the design of widgets has changed, and we most likely need to update our designs. For example, without changing anything, this is how the current &lt;a href=&#34;https://itunes.apple.com/ie/app/bikey/id1048962300?mt=8&#34;&gt;Bikey&lt;/a&gt; widget looks on iOS 10;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://petethedeveloper.com/images/posts/ios10WidgetImage1.png&#34; alt=&#34;Bikey widget&#34; title=&#34;Bikey widget&#34; /&gt;&lt;/p&gt;

&lt;p&gt;It looks pretty bad, and clearly needs to be updated. The Human Interface Guidelines are &lt;a href=&#34;https://developer.apple.com/ios/human-interface-guidelines/extensions/widgets/&#34;&gt;here&lt;/a&gt; to help. In Bikeys case, these two in particular are of interest;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;“In general, use the system font in black or dark gray for text”.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;“Avoid customizing the background of a widget.”&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Updating our designs based on the above, the post-op Bikey widget now looks perfectly at home with it’s siblings;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://petethedeveloper.com/images/posts/ios10WidgetImage2.png&#34; alt=&#34;Bikey widget&#34; title=&#34;Bikey widget&#34; /&gt;&lt;/p&gt;

&lt;p&gt;That’s it. Just (hopefully) two simple steps to get your app widget ready for it’s big day. Roll on September.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Migrating an App to Swift 3</title>
      <link>https://petethedeveloper.com/post/migratingToSwift3/</link>
      <pubDate>Tue, 09 Aug 2016 11:04:12 +0100</pubDate>
      
      <guid>https://petethedeveloper.com/post/migratingToSwift3/</guid>
      <description>

&lt;p&gt;I recently migrated &lt;a href=&#34;https://itunes.apple.com/ie/app/bikey/id1048962300?mt=8&#34;&gt;Bikey&lt;/a&gt; to Swift 3…and I actually (reasonably) enjoyed the process. I based my migration strategy on Jesse Squires excellent &lt;a href=&#34;http://www.jessesquires.com/migrating-to-swift-3/&#34;&gt;post&lt;/a&gt;, and the official migration &lt;a href=&#34;https://swift.org/migration-guide/&#34;&gt;guide&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Here I describe a possible approach to Swift 3 app migration which you may find useful, based on how it went for me.&lt;/p&gt;

&lt;h2 id=&#34;the-approach&#34;&gt;The Approach&lt;/h2&gt;

&lt;p&gt;We approach the migration process in two main stages; dependency migration and main app migration.&lt;/p&gt;

&lt;h3 id=&#34;dependencies&#34;&gt;Dependencies&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Run the Xcode Swift Migration Assistant to migrate our own frameworks/pods that we use. Ensure all framework tests are passing.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Check third-party frameworks for available Swift 3 branches. Open PRs for third-party frameworks that do not yet have Swift 3 branches. As above, migrate these using the Xcode Swift Migration Assistant. If PRs cannot be opened (e.g no Github source access and no response from current maintainers), fork repositories and migrate. Ensure all framework tests are passing.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Update the app podfile to use the Swift 3 branch of all Swift frameworks, using the ‘:branch =&amp;gt; …’ podfile specifier. If we needed to fork a repository we also update the podfile to point to the correct repository location.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;the-app&#34;&gt;The App&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Run the Xcode Swift Migration Assistant to migrate each app target to Swift 3. For example, start with the main app target, then any extension targets, then test targets etc. It’s easier to do this one target at a time, rather than deal with the entire code base at once.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Fix any issues the Swift Migration Assistant missed. It will miss a few.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Optionally manually refactor code according to the Swift API guidelines. Although no necessary to get your app building, I thoroughly recommend this. The guidelines make sense, and we all love clean code.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Ensure all app tests are passing.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;notes&#34;&gt;Notes&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The Xcode Swift Migration Assistant is not perfect, it misses things, but in general it works well.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Migrate using the latest Xcode beta (beta 5), to avoid going from beta 2 to beta 3, beta 3 to beta 4 etc.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;When presented with the Swift Migration Assistant code changes, read through all of them. It’s good to double check and it’s an easy way to get your mind in Swift 3 mode.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;I encountered an issue where third-party framework A had a dependency on third-party framework B, which had not yet been migrated. I needed to fork B, migrate it, and then override B’s source location in my own podfile. See &lt;a href=&#34;https://github.com/cocoapods/cocoapods/issues/3901&#34;&gt;this&lt;/a&gt; thread for more.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That’s it. Happy migrating!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Swift and State management</title>
      <link>https://petethedeveloper.com/post/swiftStateManagement/</link>
      <pubDate>Tue, 28 Jun 2016 11:04:12 +0100</pubDate>
      
      <guid>https://petethedeveloper.com/post/swiftStateManagement/</guid>
      <description>&lt;p&gt;I was recently refactoring a UIViewController which had a large number of states. The view controller’s state could transition to one or more other states, depending on a number of variables (do we have the user’s current location, have we successfully retrieved data, is this a fresh launch, or was the app backgrounded). When the state did change, I needed to perform certain actions to configure our view controller.&lt;/p&gt;

&lt;p&gt;It’s quite a common scenario, and not overly complicated, but I thought Swift would help come up with a clean solution. Here is the approach I took.&lt;/p&gt;

&lt;p&gt;Swift &lt;a href=&#34;https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html&#34;&gt;enums&lt;/a&gt; provide our states. This gives us a type-safe way to work with a finite set of states.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;enum State {
case initial
case launched
case launchingWithLocation
case launchingWithoutLocation
case running
case backgrounded
case fromBackground
case fromBackgroundWithLocation
case fromBackgroundWithoutLocation
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To control state transitioning, we use a method which takes a number of parameters. These parameters are the variables that help decide which state we want to transition to. As not all states will care about the value of each parameter, we give them default values. We use a Swift tuple to create a composite state of our current state and our parameters. We then use a switch statement to change state, depending on the tuple. If we don’t care about the value of one of our tuple elements, we simply ignore it using _ in a case statement.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;private func changeState(hasLocation: Bool = true, isBackgrounding: Bool = false) {
    let compositeState = (state, hasLocation, isBackgrounding)
    switch compositeState {
    case (.launched, true, false):
       state = .launchingWithLocation
    case (.launched, false, false):
       state = .launchingWithoutLocation
    case (.launched, _, true):
       state = .fromBackground
    case (.launchingWithLocation, _, false):
       state = .running
    case (.running, _, true):
       state = .backgrounded
    case (.backgrounded, _, _):
       state = .fromBackground
    case (.fromBackground, true, _):
       state = .fromBackgroundWithLocation
    case (.fromBackground, false, _):
       state = .fromBackgroundWithoutLocation
    case (.fromBackgroundWithLocation, true, _):
       state = .running
    default:
       break
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lastly, to perform certain actions when our state does change, we use the extremely useful didSet property observer. &lt;a href=&#34;https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID262&#34;&gt;Property observers&lt;/a&gt; observe a property’s value, and allow us to respond to changes of the value. The didSet property observer is called immediately after a new value is stored. We also make use of the oldValue parameter. This is a constant parameter automatically passed to didSet which contains the old property value. In our case, we use the oldValue property to perform different actions for different states depending on what the old state value was.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;private var state = State.initial {
    didSet {
       switch state {
       case .launched:
          // Do launch specific stuff, like get user&#39;s location
          break
       case .launchingWithLocation:
          // Yeah! We have location, do stuff like make API calls
          // We can also act depending on how we got to this state
          switch oldValue {
          case .launched:
             // Do launch with location specific stuff
             break
          case .fromBackground:
             // Do from background with location specific stuff
             break
          default:
             break
          }
       case .launchingWithoutLocation:
          // Sad, no location, but do some stuff anyway  
          break
       case .running:
          // Woohoo, we are fully running so do cool stuff here
          break
       case .backgrounded:
          // Backgrounded, do stuff like stop location updates
          break
       case .fromBackground:
          // Coming from background, do stuff like re-start location
          break
       case .fromBackgroundWithLocation:
          // Yeah! Back AND have location, make API calls
          break
       default:
          break
       }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That’s it! Gist &lt;a href=&#34;https://gist.github.com/superpeteblaze/4114e34bdff308f49b0fa6ffddb65095&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Swift-ly creating a location-based iOS Today Widget</title>
      <link>https://petethedeveloper.com/post/swiftLocationBasedWidget/</link>
      <pubDate>Thu, 24 Mar 2016 11:04:12 +0100</pubDate>
      
      <guid>https://petethedeveloper.com/post/swiftLocationBasedWidget/</guid>
      <description>&lt;p&gt;With the latest update of Bikey, I added a Today Widget (Extension), providing users with quick and easy access to information about their nearest bike station.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://petethedeveloper.com/images/posts/swiftLocationBasedWidgetImage1.png&#34; alt=&#34;Bikey today extension&#34; title=&#34;Bikey today extension&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Creating such a Today Widget, which is based on the user’s location, is accomplished as follows (this assumes that location access for the containing app/widget has been granted);&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Add a Today Widget to our app. This gives us a ready-made view controller which implements the NCWidgetProviding protocol. This protocol provides the ability to customize the appearance and behavior of our Widget. We add the following properties to our view controller;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// This is used to let our widget know an update is required or not
private var updateResult = NCUpdateResult.NoData
// We use a lazy instance of CLLocationManager to get the user&#39;s location
lazy private var locman = CLLocationManager()
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;In our viewDidLoad and viewWillAppear functions we set our location manager delegate and request location updates respectively;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;override func viewDidLoad() {
   super.viewDidLoad()

   locman.delegate = self
}
override func viewWillAppear(animated: Bool) {          
   super.viewWillAppear(animated)
   locman.startUpdatingLocation()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;In the CLLLocationMangerDelegate function didUpdateLocations,we use our retrieved location data, and set our Widget update result to NewData;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func locationManager(manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
   // Do stuff with the retrieved location, update our display and  
   then set our update result to NewData
   // doStuff()
   updateDisplay()
   updateResult = .NewData
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Finally, in our NCWidgetProviding protocol function widgetPerformUpdateWithCompletionHandler, we use our update result to indicate that a Widget update is required;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func widgetPerformUpdateWithCompletionHandler(completionHandler: ((NCUpdateResult) -&amp;gt; Void)) {
   // If an error is encountered, use NCUpdateResult.Failed
   // If there’s no update required, use NCUpdateResult.NoData
   // If there’s an update, use NCUpdateResult.NewData
   completionHandler(updateResult)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That’s it! We can now display location-based data in our iOS Today Widget.&lt;/p&gt;

&lt;p&gt;Of course, we can iterate on this and add error handling etc., but this is enough to get us started.&lt;/p&gt;

&lt;p&gt;The full Gist can be found &lt;a href=&#34;https://gist.github.com/superpeteblaze/eca594903710ab032086&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Referencing a weak ‘self’ in Swift Protocol Extensions</title>
      <link>https://petethedeveloper.com/post/weakSelfSwiftProtocol/</link>
      <pubDate>Sun, 14 Feb 2016 11:04:12 +0100</pubDate>
      
      <guid>https://petethedeveloper.com/post/weakSelfSwiftProtocol/</guid>
      <description>&lt;p&gt;I recently released Bikey for iOS. It’s an app that helps you to find the nearest city bike station, providing you with information such as available bikes/parking spaces, distance to station etc.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://petethedeveloper.com/images/posts/weakSelfSwiftProtocolImage1.png&#34; alt=&#34;Bikey screenshot&#34; title=&#34;Bikey screenshot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;It’s written entirely in Swift, and during it’s development I encountered an interesting problem.&lt;/p&gt;

&lt;p&gt;I had created a protocol with an accompianing protocol extension. The extension contained a base implementation of one of my protocol functions. In this function implementation, I was making a network request which needed to call another of the protocol functions in it’s completion closure. Being mindful of retain cycles, I wanted to use a weak reference to self when calling this other protocol function. I have re-created this scenario in the following code;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://petethedeveloper.com/images/posts/weakSelfSwiftProtocolImage2.png&#34; alt=&#34;Code snippet 2&#34; title=&#34;Code snippet 2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As you can see, trying to create a weak reference to self doesn’t work. But why? Well, the reason is that we can’t create a weak reference to a value type (e.g. Array, String, etc…) because these are structs and not classes. We can only create weak references to class types.&lt;/p&gt;

&lt;p&gt;So, how to solve this? It turns out there are a couple to ways to solve this, but the solution I chose was to simply indicate that the protocol is of class type, as follows;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://petethedeveloper.com/images/posts/weakSelfSwiftProtocolImage3.png&#34; alt=&#34;Code snippet 3&#34; title=&#34;Code snippet 3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This allowed me to safely reference self in my closure, which in turn meant that Bikey finally made it in to the app store.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>